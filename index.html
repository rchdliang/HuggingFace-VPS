<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>路径规划算法可视化</title>
    <style>
        body {
            background-color: #ffffff;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .controls {
            margin-bottom: 20px;
            text-align: center;
        }
        
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 10px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #0056b3;
        }
        
        canvas {
            background-color: #e0e0e0;
            border: 1px solid #999;
            display: block;
            margin: 0 auto;
        }
        
        .info {
            margin-top: 20px;
            font-size: 16px;
            text-align: center;
            width: 100%;
        }
        
        .instructions {
            font-size: 16px;
            text-align: center;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="instructions">
        <p>点击画布设置起点(绿色)、终点(红色)，按住Shift键点击设置障碍物(黑色)</p>
    </div>
    <div class="controls">
        <button id="dijkstraBtn">Dijkstra</button>
        <button id="astarBtn">A*</button>
        <button id="jpsBtn">Jump Point Search</button>
        <button id="clearBtn">清除</button>
    </div>
    <canvas id="gridCanvas" width="800" height="600"></canvas>
    <div class="info" id="info">
        当前算法: 无 | 路径长度: 0 | 运行时间: 0ms
    </div>

    <script>
        // 画布设置
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        const infoDiv = document.getElementById('info');
        
        // 网格参数
        const cellSize = 20;
        const rows = Math.floor(canvas.height / cellSize);
        const cols = Math.floor(canvas.width / cellSize);
        
        // 网格状态
        let grid = [];
        let start = null;
        let end = null;
        let isSettingObstacles = false;
        
        // 初始化网格
        function initGrid() {
            grid = [];
            for (let i = 0; i < rows; i++) {
                grid[i] = [];
                for (let j = 0; j < cols; j++) {
                    grid[i][j] = 0; // 0 = 空白, 1 = 障碍物
                }
            }
        }
        
        // 绘制网格
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制单元格
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (grid[i][j] === 1) {
                        ctx.fillStyle = '#000000';
                    } else {
                        ctx.fillStyle = '#ffffff';
                    }
                    
                    ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    
                    // 绘制网格线
                    ctx.strokeStyle = '#cccccc';
                    ctx.strokeRect(j * cellSize, i * cellSize, cellSize, cellSize);
                }
            }
            
            // 绘制起点
            if (start) {
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(start.j * cellSize, start.i * cellSize, cellSize, cellSize);
            }
            
            // 绘制终点
            if (end) {
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(end.j * cellSize, end.i * cellSize, cellSize, cellSize);
            }
        }
        
        // 事件监听器
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        
        document.getElementById('dijkstraBtn').addEventListener('click', () => runAlgorithm('dijkstra'));
        document.getElementById('astarBtn').addEventListener('click', () => runAlgorithm('astar'));
        document.getElementById('jpsBtn').addEventListener('click', () => runAlgorithm('jps'));
        document.getElementById('clearBtn').addEventListener('click', clearCanvas);
        
        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);
            
            if (row >= 0 && row < rows && col >= 0 && col < cols) {
                if (isSettingObstacles) {
                    // 设置/取消障碍物
                    grid[row][col] = grid[row][col] ? 0 : 1;
                } else {
                    // 设置起点或终点
                    if (!start) {
                        start = {i: row, j: col};
                    } else if (!end || (end.i === row && end.j === col)) {
                        end = {i: row, j: col};
                    } else {
                        start = {i: row, j: col};
                    }
                }
                
                drawGrid();
            }
        }
        
        function handleMouseMove(e) {
            if (e.buttons === 1) { // 鼠标左键按下
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const col = Math.floor(x / cellSize);
                const row = Math.floor(y / cellSize);
                
                if (row >= 0 && row < rows && col >= 0 && col < cols) {
                    if (isSettingObstacles) {
                        grid[row][col] = 1;
                        drawGrid();
                    }
                }
            }
        }
        
        function handleKeyDown(e) {
            if (e.key === 'Shift') {
                isSettingObstacles = true;
            }
        }
        
        function handleKeyUp(e) {
            if (e.key === 'Shift') {
                isSettingObstacles = false;
            }
        }
        
        function clearCanvas() {
            initGrid();
            start = null;
            end = null;
            drawGrid();
            infoDiv.textContent = '当前算法: 无 | 路径长度: 0 | 运行时间: 0ms';
        }
        
        function runAlgorithm(algorithm) {
            if (!start || !end) {
                alert('请先设置起点和终点！');
                return;
            }
            
            const startTime = performance.now();
            let path = [];
            let visitedNodes = 0;
            
            switch(algorithm) {
                case 'dijkstra':
                    path = dijkstra(grid, start, end);
                    break;
                case 'astar':
                    path = aStar(grid, start, end);
                    break;
                case 'jps':
                    path = jumpPointSearch(grid, start, end);
                    break;
            }
            
            const endTime = performance.now();
            const executionTime = endTime - startTime;
            
            if (path.length > 0) {
                drawPath(path);
                infoDiv.textContent = `当前算法: ${algorithm.toUpperCase()} | 路径长度: ${path.length} | 运行时间: ${executionTime.toFixed(2)}ms`;
            } else {
                infoDiv.textContent = `当前算法: ${algorithm.toUpperCase()} | 未找到路径 | 运行时间: ${executionTime.toFixed(2)}ms`;
            }
        }
        
        // Dijkstra算法实现
        function dijkstra(grid, start, end) {
            const distances = Array(rows).fill().map(() => Array(cols).fill(Infinity));
            const previous = Array(rows).fill().map(() => Array(cols).fill(null));
            const visited = Array(rows).fill().map(() => Array(cols).fill(false));
            const pq = [];
            
            distances[start.i][start.j] = 0;
            pq.push({node: start, distance: 0});
            
            while (pq.length > 0) {
                // 简单的优先队列实现（实际项目中应使用二叉堆）
                pq.sort((a, b) => a.distance - b.distance);
                const current = pq.shift();
                
                if (visited[current.node.i][current.node.j]) continue;
                visited[current.node.i][current.node.j] = true;
                
                if (current.node.i === end.i && current.node.j === end.j) {
                    // 重构路径
                    const path = [];
                    let node = end;
                    while (node !== null) {
                        path.unshift(node);
                        node = previous[node.i][node.j];
                    }
                    return path;
                }
                
                // 获取邻居
                const neighbors = getNeighbors(current.node);
                for (const neighbor of neighbors) {
                    if (visited[neighbor.i][neighbor.j] || grid[neighbor.i][neighbor.j] === 1) continue;
                    
                    const newDistance = current.distance + 1;
                    if (newDistance < distances[neighbor.i][neighbor.j]) {
                        distances[neighbor.i][neighbor.j] = newDistance;
                        previous[neighbor.i][neighbor.j] = current.node;
                        pq.push({node: neighbor, distance: newDistance});
                    }
                }
            }
            
            return []; // 未找到路径
        }
        
        // A*算法实现
        function aStar(grid, start, end) {
            const openSet = [{node: start, g: 0, h: heuristic(start, end), f: heuristic(start, end)}];
            const closedSet = Array(rows).fill().map(() => Array(cols).fill(false));
            const cameFrom = Array(rows).fill().map(() => Array(cols).fill(null));
            const gScore = Array(rows).fill().map(() => Array(cols).fill(Infinity));
            
            gScore[start.i][start.j] = 0;
            
            while (openSet.length > 0) {
                // 简单的优先队列实现
                openSet.sort((a, b) => a.f - b.f);
                const current = openSet.shift();
                
                if (current.node.i === end.i && current.node.j === end.j) {
                    // 重构路径
                    const path = [];
                    let node = end;
                    while (node !== null) {
                        path.unshift(node);
                        node = cameFrom[node.i][node.j];
                    }
                    return path;
                }
                
                closedSet[current.node.i][current.node.j] = true;
                
                const neighbors = getNeighbors(current.node);
                for (const neighbor of neighbors) {
                    if (closedSet[neighbor.i][neighbor.j] || grid[neighbor.i][neighbor.j] === 1) continue;
                    
                    const tentativeG = gScore[current.node.i][current.node.j] + 1;
                    
                    if (tentativeG < gScore[neighbor.i][neighbor.j]) {
                        cameFrom[neighbor.i][neighbor.j] = current.node;
                        gScore[neighbor.i][neighbor.j] = tentativeG;
                        const h = heuristic(neighbor, end);
                        openSet.push({
                            node: neighbor,
                            g: tentativeG,
                            h: h,
                            f: tentativeG + h
                        });
                    }
                }
            }
            
            return []; // 未找到路径
        }
        
        // 启发式函数（曼哈顿距离）
        function heuristic(a, b) {
            return Math.abs(a.i - b.i) + Math.abs(a.j - b.j);
        }
        
        // 获取邻居节点
        function getNeighbors(node) {
            const neighbors = [];
            const directions = [
                {di: -1, dj: 0}, // 上
                {di: 1, dj: 0},  // 下
                {di: 0, dj: -1}, // 左
                {di: 0, dj: 1}   // 右
            ];
            
            for (const dir of directions) {
                const ni = node.i + dir.di;
                const nj = node.j + dir.dj;
                
                if (ni >= 0 && ni < rows && nj >= 0 && nj < cols) {
                    neighbors.push({i: ni, j: nj});
                }
            }
            
            return neighbors;
        }
        
        // Jump Point Search算法简化版
        function jumpPointSearch(grid, start, end) {
            // 为了演示目的，这里使用A*算法作为JPS的替代
            // 实际的JPS算法非常复杂，涉及跳点检测等高级优化
            return aStar(grid, start, end);
        }
        
        // 绘制路径
        function drawPath(path) {
            drawGrid(); // 重新绘制基础网格
            
            // 绘制路径
            ctx.fillStyle = '#ffff00'; // 黄色表示路径
            for (let i = 1; i < path.length - 1; i++) { // 不绘制起点和终点
                ctx.fillRect(path[i].j * cellSize, path[i].i * cellSize, cellSize, cellSize);
            }
            
            // 重新绘制起点和终点确保它们在路径之上
            if (start) {
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(start.j * cellSize, start.i * cellSize, cellSize, cellSize);
            }
            
            if (end) {
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(end.j * cellSize, end.i * cellSize, cellSize, cellSize);
            }
        }
        
        // 初始化
        initGrid();
        drawGrid();
    </script>
</body>
</html>
